!function () {
    "use strict";

    function t(o) {
        if (!o) throw new Error("No se pasaron opciones al constructor de Waypoint");
        if (!o.element) throw new Error("No se pas贸 la opci贸n de elemento al constructor de Waypoint");
        if (!o.handler) throw new Error("No se pas贸 la opci贸n de controlador al constructor de Waypoint");

        this.key = "waypoint-" + e;
        this.options = t.Adapter.extend({}, t.defaults, o);
        this.element = this.options.element;
        this.adapter = new t.Adapter(this.element);
        this.callback = o.handler;
        this.axis = this.options.horizontal ? "horizontal" : "vertical";
        this.enabled = this.options.enabled;
        this.triggerPoint = null;
        this.group = t.Group.findOrCreate({ name: this.options.group, axis: this.axis });
        this.context = t.Context.findOrCreateByElement(this.options.context);
        
        t.offsetAliases[this.options.offset] && (this.options.offset = t.offsetAliases[this.options.offset]);
        
        this.group.add(this);
        this.context.add(this);
        i[this.key] = this;
        e += 1;
    }

    var e = 0,
        i = {};
    
    t.prototype.queueTrigger = function (t) {
        this.group.queueTrigger(this, t);
    };
    
    t.prototype.trigger = function (t) {
        this.enabled && this.callback && this.callback.apply(this, t);
    };
    
    t.prototype.destroy = function () {
        this.context.remove(this);
        this.group.remove(this);
        delete i[this.key];
    };
    
    t.prototype.disable = function () {
        return this.enabled = !1, this;
    };
    
    t.prototype.enable = function () {
        return this.context.refresh(), this.enabled = !0, this;
    };
    
    t.prototype.next = function () {
        return this.group.next(this);
    };
    
    t.prototype.previous = function () {
        return this.group.previous(this);
    };
    
    t.invokeAll = function (t) {
        var e = [];
        for (var o in i) e.push(i[o]);
        for (var n = 0, r = e.length; r > n; n++) e[n][t]();
    };
    
    t.destroyAll = function () {
        t.invokeAll("destroy");
    };
    
    t.disableAll = function () {
        t.invokeAll("disable");
    };
    
    t.enableAll = function () {
        t.invokeAll("enable");
    };
    
    t.refreshAll = function () {
        t.Context.refreshAll();
    };
    
    t.viewportHeight = function () {
        return window.innerHeight || document.documentElement.clientHeight;
    };
    
    t.viewportWidth = function () {
        return document.documentElement.clientWidth;
    };
    
    t.adapters = [];
    
    t.defaults = {
        context: window,
        continuous: !0,
        enabled: !0,
        group: "default",
        horizontal: !1,
        offset: 0
    };
    
    t.offsetAliases = {
        "bottom-in-view": function () {
            return this.context.innerHeight() - this.adapter.outerHeight();
        },
        "right-in-view": function () {
            return this.context.innerWidth() - this.adapter.outerWidth();
        }
    };
    
    window.Waypoint = t;
}(), function () {
    "use strict";

    function t(t) {
        window.setTimeout(t, 1e3 / 60);
    }

    function e(t) {
        this.element = t;
        this.Adapter = n.Adapter;
        this.adapter = new this.Adapter(t);
        this.key = "waypoint-context-" + i;
        this.didScroll = !1;
        this.didResize = !1;
        this.oldScroll = {
            x: this.adapter.scrollLeft(),
            y: this.adapter.scrollTop()
        };
        this.waypoints = {
            vertical: {},
            horizontal: {}
        };
        t.waypointContextKey = this.key;
        o[t.waypointContextKey] = this;
        i += 1;
        this.createThrottledScrollHandler();
        this.createThrottledResizeHandler();
    }

    var i = 0,
        o = {},
        n = window.Waypoint,
        r = window.onload;
    
    e.prototype.add = function (t) {
        var e = t.options.horizontal ? "horizontal" : "vertical";
        this.waypoints[e][t.key] = t;
        this.refresh();
    };
    
    e.prototype.checkEmpty = function () {
        var t = this.Adapter.isEmptyObject(this.waypoints.horizontal),
            e = this.Adapter.isEmptyObject(this.waypoints.vertical);
        
        t && e && (this.adapter.off(".waypoints"), delete o[this.key]);
    };
    
    e.prototype.createThrottledResizeHandler = function () {
        function t() {
            e.handleResize(), e.didResize = !1;
        }
        var e = this;
        this.adapter.on("resize.waypoints", function () {
            !e.didResize || (e.didResize = !0, n.requestAnimationFrame(t));
        });
    };
    
    e.prototype.createThrottledScrollHandler = function () {
        function t() {
            e.handleScroll(), e.didScroll = !1;
        }
        var e = this;
        this.adapter.on("scroll.waypoints", function () {
            (!e.didScroll || n.isTouch) && (e.didScroll = !0, n.requestAnimationFrame(t));
        });
    };
    
    e.prototype.handleResize = function () {
        n.Context.refreshAll();
    };
    
    e.prototype.handleScroll = function () {
        var t = {},
            e = {
                horizontal: {
                    newScroll: this.adapter.scrollLeft(),
                    oldScroll: this.oldScroll.x,
                    forward: "right",
                    backward: "left"
                },
                vertical: {
                    newScroll: this.adapter.scrollTop(),
                    oldScroll: this.oldScroll.y,
                    forward: "down",
                    backward: "up"
                }
            };
        
        for (var i in e) {
            var o = e[i],
                n = o.newScroll > o.oldScroll ? o.forward : o.backward;

            for (var r in this.waypoints[i]) {
                var s = this.waypoints[i][r],
                    a = o.oldScroll < s.triggerPoint,
                    l = o.newScroll >= s.triggerPoint;
                
                (a && l || !a && !l) && (s.queueTrigger(n), t[s.group.id] = s.group);
            }
        }
        
        for (var h in t) t[h].flushTriggers();
        this.oldScroll = {
            x: e.horizontal.newScroll,
            y: e.vertical.newScroll
        };
    };
    
    e.prototype.innerHeight = function () {
        return this.element == this.element.window ? n.viewportHeight() : this.adapter.innerHeight();
    };
    
    e.prototype.remove = function (t) {
        delete this.waypoints[t.axis][t.key];
        this.checkEmpty();
    };
    
    e.prototype.innerWidth = function () {
        return this.element == this.element.window ? n.viewportWidth() : this.adapter.innerWidth();
    };
    
    e.prototype.destroy = function () {
        var t = [];
        for (var e in this.waypoints)
            for (var i in this.waypoints[e]) t.push(this.waypoints[e][i]);
        for (var o = 0, n = t.length; n > o; o++) t[o].destroy();
    };
    
    e.prototype.refresh = function () {
        var t,
            e = this.element == this.element.window,
            i = e ? void 0 : this.adapter.offset(),
            o = {};
        
        for (var r in this.handleScroll(), t = {
            horizontal: {
                contextOffset: e ? 0 : i.left,
                contextScroll: e ? 0 : this.oldScroll.x,
                contextDimension: this.innerWidth(),
                oldScroll: this.oldScroll.x,
                forward: "right",
                backward: "left",
                offsetProp: "left"
            },
            vertical: {
                contextOffset: e ? 0 : i.top,
                contextScroll: e ? 0 : this.oldScroll.y,
                contextDimension: this.innerHeight(),
                oldScroll: this.oldScroll.y,
                forward: "down",
                backward: "up",
                offsetProp: "top"
            }
        }) {
            var s = t[r];
            for (var a in this.waypoints[r]) {
                var l, h, u, c,
                    p = this.waypoints[r][a],
                    d = p.options.offset,
                    f = p.triggerPoint,
                    y = 0,
                    w = null == f;

                p.element !== p.element.window && (y = p.adapter.offset()[s.offsetProp]);
                
                "function" == typeof d ? d = d.apply(p) : "string" == typeof d && (d = parseFloat(d), p.options.offset.indexOf("%") > -1 && (d = Math.ceil(s.contextDimension * d / 100)));
                
                l = s.contextScroll - s.contextOffset;
                p.triggerPoint = y + l - d;
                h = f < s.oldScroll;
                u = p.triggerPoint >= s.oldScroll;
                w && (p.triggerPoint = y + l - Math.ceil(p.adapter.outerHeight()));
                (h && u || !h && !u) && (p.queueTrigger(s.backward), o[p.group.id] = p.group);
            }
        }
        
        for (var g in o) o[g].flushTriggers();
    };
    
    n.Context = e;
}();
